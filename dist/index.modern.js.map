{"version":3,"file":"index.modern.js","sources":["../index.js"],"sourcesContent":["const state = new Map()\nconst isRtl = window.getComputedStyle(document.documentElement).direction === 'rtl'\n\nconst KEYCODE = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n}\n\n// when container or children get focus\nconst onFocusin = e => {\n  const {currentTarget: rover} = e\n  if (state.get('last_rover') == rover) return\n  if (state.has(rover)) {\n    activate(rover, state.get(rover).active)\n    state.set('last_rover', rover)\n  }\n}\n\nconst onKeydown = e => {\n  const {currentTarget: rover} = e\n\n  switch (e.keyCode) {\n    case KEYCODE[isRtl ? 'LEFT' : 'RIGHT']:\n    case KEYCODE.DOWN:\n      e.preventDefault()\n      focusNextItem(rover)\n      break\n    case KEYCODE[isRtl ? 'RIGHT' : 'LEFT']:\n    case KEYCODE.UP:\n      e.preventDefault()\n      focusPreviousItem(rover)\n      break\n  }\n}\n\nconst mo = new MutationObserver((mutationList, observer) => {\n  mutationList\n    .filter(x => x.removedNodes.length > 0)\n    .forEach(mutation => {\n      [...mutation.removedNodes]\n        .filter(x => x.nodeType === 1)\n        .forEach(removedEl => {\n          state.forEach((val,key) => {\n            if (key ==='last_rover') return\n            if (removedEl.contains(key)) {\n              key.removeEventListener('focusin', onFocusin)\n              key.removeEventListener('keydown', onKeydown)\n\n              state.delete(key)\n              val.targets.forEach(a => a.tabIndex = '') \n\n              if (state.size === 0 || (state.size === 1 && state.has('last_rover'))) {\n                state.clear()\n                mo.disconnect()\n              }\n            }\n          })\n        })\n    })\n})         \n\nexport const rovingIndex = ({element:rover, target:selector}) => {\n  // this api allows empty or a query string\n  const target_query = selector || ':scope *'\n  const targets = rover.querySelectorAll(target_query)\n  const startingPoint = targets[0]\n\n  // take container out of the focus flow\n  rover.tabIndex = -1\n  // and all the children\n  targets.forEach(a => a.tabIndex = -1)\n  // except the first target, that accepts focus\n  startingPoint.tabIndex = 0\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    active: startingPoint,\n    index: 0,\n  })\n\n  rover.addEventListener('focusin', onFocusin)\n  // watch for arrow keys\n  rover.addEventListener('keydown', onKeydown)\n\n  mo.observe(document, {\n    childList: true,\n    subtree: true\n  }) \n}\n\nconst focusNextItem = rover => {\n  const rx = state.get(rover)\n\n  // increment state index\n  rx.index += 1\n\n  // clamp navigation to target bounds\n  if (rx.index > rx.targets.length - 1)\n    rx.index = rx.targets.length - 1\n\n  // use rover index state to find next\n  let next = rx.targets[rx.index]\n\n  // found something, activate it\n  next && activate(rover, next)\n}\n\nconst focusPreviousItem = rover => {\n  const rx = state.get(rover)\n\n  // decrement from the state index\n  rx.index -= 1\n\n  // clamp to 0 and above only\n  if (rx.index < 1)\n    rx.index = 0\n\n  // use rover index state to find next\n  let prev = rx.targets[rx.index]\n\n  // found something, activate it\n  prev && activate(rover, prev)\n}\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover)\n\n  // remove old tab index item\n  rx.active.tabIndex = -1\n\n  // set new active item and focus it\n  rx.active = item\n  rx.active.tabIndex = 0\n  rx.active.focus()\n}\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","KEYCODE","LEFT","UP","RIGHT","DOWN","onFocusin","e","currentTarget","rover","get","has","activate","active","set","onKeydown","keyCode","preventDefault","focusNextItem","focusPreviousItem","mo","MutationObserver","mutationList","observer","filter","x","removedNodes","length","forEach","mutation","nodeType","removedEl","val","key","contains","removeEventListener","delete","targets","a","tabIndex","size","clear","disconnect","rovingIndex","element","target","selector","querySelectorAll","startingPoint","index","addEventListener","observe","childList","subtree","rx","next","prev","item","focus"],"mappings":"AAAA,MAAMA,EAAQ,IAAIC,IACZC,EAAwE,QAAhEC,OAAOC,iBAAiBC,SAASC,iBAAiBC,UAE1DC,EAAU,CACdC,KAAM,GACNC,GAAI,GACJC,MAAO,GACPC,KAAM,IAIFC,EAAYC,IAChB,MAAOC,cAAeC,GAASF,EAC3Bd,EAAMiB,IAAI,eAAiBD,GAC3BhB,EAAMkB,IAAIF,KACZG,EAASH,EAAOhB,EAAMiB,IAAID,GAAOI,QACjCpB,EAAMqB,IAAI,aAAcL,KAItBM,EAAYR,IAChB,MAAOC,cAAeC,GAASF,EAE/B,OAAQA,EAAES,SACR,KAAKf,EAAQN,EAAQ,OAAS,SAC9B,KAAKM,EAAQI,KACXE,EAAEU,iBACFC,EAAcT,GACd,MACF,KAAKR,EAAQN,EAAQ,QAAU,QAC/B,KAAKM,EAAQE,GACXI,EAAEU,iBACFE,EAAkBV,KAKlBW,EAAK,IAAIC,iBAAiB,CAACC,EAAcC,KAC7CD,EACGE,OAAOC,GAAKA,EAAEC,aAAaC,OAAS,GACpCC,QAAQC,IACP,IAAIA,EAASH,cACVF,OAAOC,GAAoB,IAAfA,EAAEK,UACdF,QAAQG,IACPtC,EAAMmC,QAAQ,CAACI,EAAIC,KACN,eAAPA,GACAF,EAAUG,SAASD,KACrBA,EAAIE,oBAAoB,UAAW7B,GACnC2B,EAAIE,oBAAoB,UAAWpB,GAEnCtB,EAAM2C,OAAOH,GACbD,EAAIK,QAAQT,QAAQU,GAAKA,EAAEC,SAAW,KAEnB,IAAf9C,EAAM+C,MAA8B,IAAf/C,EAAM+C,MAAc/C,EAAMkB,IAAI,iBACrDlB,EAAMgD,QACNrB,EAAGsB,uBAQNC,EAAc,EAAEC,QAAQnC,EAAOoC,OAAOC,MAEjD,MACMT,EAAU5B,EAAMsC,iBADDD,GAAY,YAE3BE,EAAgBX,EAAQ,GAG9B5B,EAAM8B,UAAY,EAElBF,EAAQT,QAAQU,GAAKA,EAAEC,UAAY,GAEnCS,EAAcT,SAAW,EAIzB9C,EAAMqB,IAAIL,EAAO,CACf4B,QAAAA,EACAxB,OAAQmC,EACRC,MAAO,IAGTxC,EAAMyC,iBAAiB,UAAW5C,GAElCG,EAAMyC,iBAAiB,UAAWnC,GAElCK,EAAG+B,QAAQrD,SAAU,CACnBsD,WAAW,EACXC,SAAS,KAIPnC,EAAgBT,IACpB,MAAM6C,EAAK7D,EAAMiB,IAAID,GAGrB6C,EAAGL,OAAS,EAGRK,EAAGL,MAAQK,EAAGjB,QAAQV,OAAS,IACjC2B,EAAGL,MAAQK,EAAGjB,QAAQV,OAAS,GAGjC,IAAI4B,EAAOD,EAAGjB,QAAQiB,EAAGL,OAGzBM,GAAQ3C,EAASH,EAAO8C,IAGpBpC,EAAoBV,IACxB,MAAM6C,EAAK7D,EAAMiB,IAAID,GAGrB6C,EAAGL,OAAS,EAGRK,EAAGL,MAAQ,IACbK,EAAGL,MAAQ,GAGb,IAAIO,EAAOF,EAAGjB,QAAQiB,EAAGL,OAGzBO,GAAQ5C,EAASH,EAAO+C,IAGpB5C,EAAW,CAACH,EAAOgD,KACvB,MAAMH,EAAK7D,EAAMiB,IAAID,GAGrB6C,EAAGzC,OAAO0B,UAAY,EAGtBe,EAAGzC,OAAS4C,EACZH,EAAGzC,OAAO0B,SAAW,EACrBe,EAAGzC,OAAO6C"}