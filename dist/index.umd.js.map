{"version":3,"file":"index.umd.js","sources":["../index.js"],"sourcesContent":["const state = new Map()\nconst isRtl = window.getComputedStyle(document.documentElement).direction === 'rtl'\n\nconst KEYCODE = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n}\n\n// when container or children get focus\nconst onFocusin = e => {\n  const {currentTarget: rover} = e\n  if (state.get('last_rover') == rover) return\n  if (state.has(rover)) {\n    activate(rover, state.get(rover).active)\n    state.set('last_rover', rover)\n  }\n}\n\nconst onKeydown = e => {\n  const {currentTarget: rover} = e\n\n  switch (e.keyCode) {\n    case KEYCODE[isRtl ? 'LEFT' : 'RIGHT']:\n    case KEYCODE.DOWN:\n      e.preventDefault()\n      focusNextItem(rover)\n      break\n    case KEYCODE[isRtl ? 'RIGHT' : 'LEFT']:\n    case KEYCODE.UP:\n      e.preventDefault()\n      focusPreviousItem(rover)\n      break\n  }\n}\n\nconst mo = new MutationObserver((mutationList, observer) => {\n  mutationList\n    .filter(x => x.removedNodes.length > 0)\n    .forEach(mutation => {\n      [...mutation.removedNodes]\n        .filter(x => x.nodeType === 1)\n        .forEach(removedEl => {\n          state.forEach((val,key) => {\n            if (key ==='last_rover') return\n            if (removedEl.contains(key)) {\n              key.removeEventListener('focusin', onFocusin)\n              key.removeEventListener('keydown', onKeydown)\n\n              state.delete(key)\n              val.targets.forEach(a => a.tabIndex = '') \n\n              if (state.size === 0 || (state.size === 1 && state.has('last_rover'))) {\n                state.clear()\n                mo.disconnect()\n              }\n            }\n          })\n        })\n    })\n})         \n\nexport const rovingIndex = ({element:rover, target:selector}) => {\n  // this api allows empty or a query string\n  const target_query = selector || ':scope *'\n  const targets = rover.querySelectorAll(target_query)\n  const startingPoint = targets[0]\n\n  // take container out of the focus flow\n  rover.tabIndex = -1\n  // and all the children\n  targets.forEach(a => a.tabIndex = -1)\n  // except the first target, that accepts focus\n  startingPoint.tabIndex = 0\n\n  // with the roving container as the key\n  // save some state and handy references\n  state.set(rover, {\n    targets,\n    active: startingPoint,\n    index: 0,\n  })\n\n  rover.addEventListener('focusin', onFocusin)\n  // watch for arrow keys\n  rover.addEventListener('keydown', onKeydown)\n\n  mo.observe(document, {\n    childList: true,\n    subtree: true\n  }) \n}\n\nconst focusNextItem = rover => {\n  const rx = state.get(rover)\n\n  // increment state index\n  rx.index += 1\n\n  // clamp navigation to target bounds\n  if (rx.index > rx.targets.length - 1)\n    rx.index = rx.targets.length - 1\n\n  // use rover index state to find next\n  let next = rx.targets[rx.index]\n\n  // found something, activate it\n  next && activate(rover, next)\n}\n\nconst focusPreviousItem = rover => {\n  const rx = state.get(rover)\n\n  // decrement from the state index\n  rx.index -= 1\n\n  // clamp to 0 and above only\n  if (rx.index < 1)\n    rx.index = 0\n\n  // use rover index state to find next\n  let prev = rx.targets[rx.index]\n\n  // found something, activate it\n  prev && activate(rover, prev)\n}\n\nconst activate = (rover, item) => {\n  const rx = state.get(rover)\n\n  // remove old tab index item\n  rx.active.tabIndex = -1\n\n  // set new active item and focus it\n  rx.active = item\n  rx.active.tabIndex = 0\n  rx.active.focus()\n}\n"],"names":["state","Map","isRtl","window","getComputedStyle","document","documentElement","direction","KEYCODE","LEFT","UP","RIGHT","DOWN","onFocusin","e","rover","currentTarget","get","has","activate","active","set","onKeydown","keyCode","preventDefault","focusNextItem","focusPreviousItem","mo","MutationObserver","mutationList","observer","filter","x","removedNodes","length","forEach","mutation","nodeType","removedEl","val","key","contains","removeEventListener","targets","a","tabIndex","size","clear","disconnect","rx","index","next","prev","item","focus","element","querySelectorAll","target","startingPoint","addEventListener","observe","childList","subtree"],"mappings":"kOAAA,IAAMA,EAAQ,IAAIC,IACZC,EAAwE,QAAhEC,OAAOC,iBAAiBC,SAASC,iBAAiBC,UAE1DC,EAAU,CACdC,KAAM,GACNC,GAAI,GACJC,MAAO,GACPC,KAAM,IAIFC,EAAY,SAAAC,GAChB,IAAsBC,EAASD,EAAxBE,cACHhB,EAAMiB,IAAI,eAAiBF,GAC3Bf,EAAMkB,IAAIH,KACZI,EAASJ,EAAOf,EAAMiB,IAAIF,GAAOK,QACjCpB,EAAMqB,IAAI,aAAcN,KAItBO,EAAY,SAAAR,GAChB,IAAsBC,EAASD,EAAxBE,cAEP,OAAQF,EAAES,SACR,KAAKf,EAAQN,EAAQ,OAAS,SAC9B,KAAKM,EAAQI,KACXE,EAAEU,iBACFC,EAAcV,GACd,MACF,KAAKP,EAAQN,EAAQ,QAAU,QAC/B,KAAKM,EAAQE,GACXI,EAAEU,iBACFE,EAAkBX,KAKlBY,EAAK,IAAIC,iBAAiB,SAACC,EAAcC,GAC7CD,EACGE,OAAO,SAAAC,UAAKA,EAAEC,aAAaC,OAAS,IACpCC,QAAQ,SAAAC,GACP,UAAIA,EAASH,cACVF,OAAO,SAAAC,UAAoB,IAAfA,EAAEK,WACdF,QAAQ,SAAAG,GACPtC,EAAMmC,QAAQ,SAACI,EAAIC,GACN,eAAPA,GACAF,EAAUG,SAASD,KACrBA,EAAIE,oBAAoB,UAAW7B,GACnC2B,EAAIE,oBAAoB,UAAWpB,GAEnCtB,SAAawC,GACbD,EAAII,QAAQR,QAAQ,SAAAS,UAAKA,EAAEC,SAAW,MAEnB,IAAf7C,EAAM8C,MAA8B,IAAf9C,EAAM8C,MAAc9C,EAAMkB,IAAI,iBACrDlB,EAAM+C,QACNpB,EAAGqB,uBAuCbvB,EAAgB,SAAAV,GACpB,IAAMkC,EAAKjD,EAAMiB,IAAIF,GAGrBkC,EAAGC,OAAS,EAGRD,EAAGC,MAAQD,EAAGN,QAAQT,OAAS,IACjCe,EAAGC,MAAQD,EAAGN,QAAQT,OAAS,GAGjC,IAAIiB,EAAOF,EAAGN,QAAQM,EAAGC,OAGzBC,GAAQhC,EAASJ,EAAOoC,IAGpBzB,EAAoB,SAAAX,GACxB,IAAMkC,EAAKjD,EAAMiB,IAAIF,GAGrBkC,EAAGC,OAAS,EAGRD,EAAGC,MAAQ,IACbD,EAAGC,MAAQ,GAGb,IAAIE,EAAOH,EAAGN,QAAQM,EAAGC,OAGzBE,GAAQjC,EAASJ,EAAOqC,IAGpBjC,EAAW,SAACJ,EAAOsC,GACvB,IAAMJ,EAAKjD,EAAMiB,IAAIF,GAGrBkC,EAAG7B,OAAOyB,UAAY,EAGtBI,EAAG7B,OAASiC,EACZJ,EAAG7B,OAAOyB,SAAW,EACrBI,EAAG7B,OAAOkC,uBA1Ee,gBAAUvC,IAARwC,QAGrBZ,EAAU5B,EAAMyC,mBAHoBC,QAET,YAE3BC,EAAgBf,EAAQ,GAG9B5B,EAAM8B,UAAY,EAElBF,EAAQR,QAAQ,SAAAS,UAAKA,EAAEC,UAAY,IAEnCa,EAAcb,SAAW,EAIzB7C,EAAMqB,IAAIN,EAAO,CACf4B,QAAAA,EACAvB,OAAQsC,EACRR,MAAO,IAGTnC,EAAM4C,iBAAiB,UAAW9C,GAElCE,EAAM4C,iBAAiB,UAAWrC,GAElCK,EAAGiC,QAAQvD,SAAU,CACnBwD,WAAW,EACXC,SAAS"}